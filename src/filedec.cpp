//filedec.cpp

#include <windows.h>
#include <stdio.h>
#include <direct.h>
#include <cstdlib>
#include <io.h>

#define DECRYPT_START 0x573
#define DECRYPT_FACTOR 0x6c078965
#define DECRYPT_FACTOR2 0x7AB3684C

DWORD CS_fileSizes[]={0x131400,0x47000,0x3000,0x65400,0x65800,0xb7800,
					0xb4400,0x9000,0x9000,0x9000,0x4800,0x11400,0x65400};

DWORD sectStarts[]={0,0x1400,0x1800};

//_H is only the header used for crypting/decrypting
#define OPTSECT_GENERAL_H			 0 //HEADER
#define OPTSECT_STADIUMNAMES_H		 4 //HEADER
#define OPTSECT_STADIUMNAMES		 5 //61 bytes for each name
#define OPTSECT_LEAGUENAMES			 6 //84 bytes each, shown name begins at byte 22
#define OPTSECT_CREATEDPLAYERS_H     7 //HEADER
#define OPTSECT_CREATEDPLAYERS       8 //124 bytes for each (up to 184) player
#define OPTSECT_SHOES				 9 //92 bytes for each of the 9 shoes
#define OPTSECT_STDPLAYERS_H		10 //HEADER
#define OPTSECT_STDPLAYERS			11 //124 bytes for each of the 5000 players
#define OPTSECT_PLAYERNUMBERS_H		12 //HEADER
#define OPTSECT_NATPLAYERNUMBERS	13 //23 bytes for each team (number=value+1)
									   //first national (64), then 0-byte-teams (2), then
									   //created players teams (8)
#define OPTSECT_CLUBPLAYERNUMBERS	14 //32 bytes for each team (number=value+1)
#define OPTSECT_NATTEAMPLAYERS		15 //46 bytes for each team (23 players * 2 bytes)
#define OPTSECT_CLUBTEAMPLAYERS		16 //64 bytes for each club team (145)
#define OPTSECT_TEAMFORMATIONS		17 //628 bytes each (national+club)
#define OPTSECT_TEAMINFOS_H			18 //HEADER
#define OPTSECT_TEAMINFOS			19 //140 bytes (club)
#define OPTSECT_TEAMKITINFOS_H		20 //HEADER
#define OPTSECT_TEAMNATKITINFOS		21 //544 bytes for each team (national)
#define OPTSECT_TEAMCLUBKITINFOS	22 //544 bytes for each team (club)


DWORD optSections[]={OPTSECT_GENERAL_H, OPTSECT_STADIUMNAMES_H, OPTSECT_CREATEDPLAYERS_H,
					OPTSECT_STDPLAYERS_H, OPTSECT_PLAYERNUMBERS_H, OPTSECT_TEAMINFOS_H,
					OPTSECT_TEAMKITINFOS_H, 24, 26};

BYTE array2[]={0x36,0x52,0x71,0x53,0x58,0x77,0x4D,0x6D,0x48,0x69,0x63,0x31,0x68,0x73,0x64,0x48,
0x69,0x79,0x77,0x4B,0x44,0x31,0x52,0x59,0x42,0x78,0x71,0x31,0x77,0x50,0x35,0x61,0x46,0x37,0x56,
0x76,0x31,0x61,0x38,0x74,0x4D,0x43,0x68,0x6A,0x6B,0x39,0x59,0x52,0x51,0x77,0x50,0x5A,0x78,0x73,
0x57,0x71,0x4C,0x33,0x55,0x35,0x4E,0x34,0x5A,0x72,0x66,0x6A,0x6D,0x36,0x32,0x5A,0x63,0x57,0x45,
0x42,0x33,0x78,0x71,0x68,0x48,0x68,0x71,0x6C,0x53,0x58,0x58,0x57,0x58,0x66,0x64,0x4A,0x48,0x72,
0x62,0x31,0x76,0x56,0x78,0x48,0x76,0x65,0x59,0x77,0x4C,0x48,0x33,0x67,0x50,0x69,0x5A,0x79,0x38,
0x71,0x4A,0x36,0x7A,0x32,0x71,0x66,0x67,0x44,0x34,0x6B,0x49,0x4F,0x48,0x59,0x72,0x73,0x76,0x72,
0x55,0x58,0x51,0x4D,0x58,0x68,0x6C,0x43,0x57,0x35,0x45,0x71,0x6D,0x67,0x6D,0x42,0x49,0x4A,0x45,
0x46,0x33,0x68,0x6F,0x51,0x42,0x36,0x75,0x54,0x45,0x57,0x63,0x73,0x64,0x30,0x78,0x39,0x58,0x51,
0x7A,0x68,0x4C,0x30,0x4D,0x6C,0x79,0x4E,0x49,0x72,0x36,0x31,0x31,0x33,0x33,0x6E,0x44,0x67,0x63,
0x43,0x47,0x48,0x35,0x70,0x66,0x77,0x67,0x65,0x6E,0x65,0x78,0x78,0x72,0x7A,0x67,0x73,0x6E,0x71,
0x69,0x61,0x51,0x39,0x41,0x66,0x36,0x5A,0x6C,0x66,0x75,0x6A,0x45,0x51,0x56,0x30,0x36,0x59,0x79,
0x31,0x79,0x75,0x56,0x37,0x72,0x6B,0x64,0x49,0x38,0x76,0x32,0x30,0x33,0x70,0x57,0x4F,0x51,0x49,
0x36,0x69,0x43,0x56,0x38,0x70,0x6E,0x71,0x74,0x42,0x4B,0x37,0x33,0x65,0x42,0x68,0x34,0x54,0x54,
0x51,0x33,0x34,0x64,0x68,0x7A,0x6D,0x64,0x4C,0x59,0x58,0x41,0x76,0x30,0x35,0x39,0x61,0x44,0x35,
0x57,0x49,0x4D,0x6C,0x54,0x66,0x6B,0x61,0x35,0x30,0x67,0x62,0x4A,0x6B,0x4A,0x42,0x52,0x6A,0x6C,
0x71,0x48,0x47,0x70,0x70,0x50,0x5A,0x39,0x6C,0x61,0x4A,0x6D,0x72,0x62,0x74,0x5A,0x35,0x69,0x5A,
0x70,0x4B,0x63,0x53,0x65,0x78,0x73,0x32,0x6B,0x4B,0x47,0x43,0x64,0x34,0x53,0x6B,0x48,0x76,0x53,
0x4C,0x6A,0x77,0x39,0x33,0x58,0x32,0x72,0x30,0x70,0x69,0x52,0x4D,0x5A,0x35,0x6F,0x49,0x51,0x5A,
0x53,0x72,0x34,0x78,0x69,0x70,0x55,0x61,0x75,0x45,0x31,0x54,0x71,0x4F,0x65,0x4B,0x35,0x39,0x52,
0x36,0x4F,0x47,0x57,0x41,0x78,0x78,0x4F,0x61,0x78,0x68,0x61,0x38,0x59,0x33,0x63,0x55,0x31,0x30,
0x69,0x65,0x72,0x77,0x64,0x49,0x39,0x36,0x74,0x59,0x6C,0x56,0x4D,0x67,0x55,0x31,0x53,0x4B,0x54,
0x33,0x75,0x50,0x56,0x79,0x5A,0x32,0x67,0x48,0x4E,0x70,0x44,0x51,0x77,0x46,0x4E,0x6C,0x56,0x77,
0x79,0x56,0x79,0x34,0x39,0x6F,0x53,0x78,0x55,0x5A,0x44,0x00};


void DeEncCode(BYTE* buf, DWORD fs);
bool CorrectChecksums(BYTE* buf);
void DecryptOptionfile(BYTE* buf, bool decrypt=true);
int main(int argc, char* argv[]);


int main(int argc, char* argv[])
{
	char newFilename[4096];
	BYTE* buf=NULL;
	DWORD fs=0;
	DWORD choice=0;
	bool successful=false;
	
	if (argc<2) {
		printf("Too few parameters!\n");
		system("PAUSE");
		return 0;
	};

	
	FILE* f = fopen(argv[1], "rb");
    if (!f) {
    	printf("Could't open file!\n");
		system("PAUSE");
		return 0;
	};
	
	fs=_filelength(_fileno(f));
	if (fs==0) {
		fclose(f);
		printf("0 Byte file!\n");
		system("PAUSE");
		return 0;
	};
	
	buf=new BYTE[fs];
    fread(buf, fs, 1, f);
    fclose(f);
    
    printf("What do you want to do?\n");
    printf("1 - Decode/Encode\n");
    printf("2 - Correct checksums (in decoded file)\n");
    printf("3 - Correct checksums -> Encode\n");
    printf("4 - Decode -> Correct checksums -> Encode\n");
    printf("5 - Decrypt Option file\n");
    printf("6 - Encrypt Option file\n");
    printf("7 - Decode -> Decrypt Option file\n");
    printf("8 - Encrypt Option file -> Correct checksums -> Encode\n");
    scanf("%d",&choice);
    
    if (choice<1 || choice>8) {
    	delete buf;
		buf=NULL;
    	return 0;
    };
    
    if (choice>=1 || choice<=8) {
		sprintf(newFilename,"%s_dec.bin",argv[1]);
		f = fopen(newFilename, "wb");
		if (!f) {
			delete buf;
			buf=NULL;
	    	printf("Could't create decoded file!\n");
			system("PAUSE");
			return 0;
		};
	};
    
    switch (choice) {
    case 1:
		DeEncCode(buf,fs);
		
		successful=true;
		break;
	
	case 2:
		if (!CorrectChecksums(buf))
			break;
			
		successful=true;
		break;
	
	case 3:
		if (!CorrectChecksums(buf))
			break;
		
		DeEncCode(buf,fs);
		
		successful=true;
		break;
	
	case 4:
		DeEncCode(buf,fs);
		
		if (!CorrectChecksums(buf))
			break;
		
		DeEncCode(buf,fs);
		
		successful=true;
		break;
	
	case 5:
		DecryptOptionfile(buf, true);
		
		successful=true;
		break;
		
	case 6:
		DecryptOptionfile(buf, false);
		
		successful=true;
		break;
			
	case 7:
		DeEncCode(buf,fs);
		
		DecryptOptionfile(buf, true);
		
		successful=true;
		break;
		
			
	case 8:
		DecryptOptionfile(buf, false);
		
		if (!CorrectChecksums(buf))
			break;
			
		DeEncCode(buf,fs);
		
		successful=true;
		break;
	};
	
    if (choice>=1 || choice<=8) {
    	if (successful)
    		fwrite(buf,fs,1,f);
		fclose(f);
	};
		
	delete buf;
	buf=NULL;
		
	system("PAUSE");
	return 0;
}

void DeEncCode(BYTE* buf, DWORD fs)
{
	DWORD param=DECRYPT_START;
    DWORD start=0;
    
    int i;
	for (i=0;i<start;i++) {
		param*=DECRYPT_FACTOR;
		param++;
	};
		
	for (i=0;i<fs;i++) {
		buf[i]^=(param & 0xff);
		param*=DECRYPT_FACTOR;
		param++;
	};
	
	printf("Decoding/Encoding was successful!\n");
	
	return;
};

bool CorrectChecksums(BYTE* buf)
{
	DWORD checksum=0;
	BYTE sectType=0;
    DWORD max=0, tmp=0;
    BYTE* sectStart=NULL;
    BYTE numSects=2;
    
    BYTE fileType=buf[12];
    // 0=option file
    // 1=replay
    // 2=formations
    // 3=cup
    // 4=league
    // 5=master league
    // 6=
    // 7=challenge training
    // 8=dribbling
    // 9=
    // 10=master league (best team)
    // 11=
    // 12=
    
	if (fileType>12) {
		printf("Unknown file type (%d)!\n",fileType);
		return false;
	};
    
    if (fileType==4 || fileType==5)
    	numSects=3;
    
    for (int i=0;i<numSects;i++) {
		sectStart=buf+sectStarts[i];
	
		sectType=sectStart[10];

		if (sectType>12) {
			printf("Unknown section type (%d)!\n",sectType);
			return false;
		};
		
		max=CS_fileSizes[sectType];
		max+=0x3ff;
		tmp=(max & 0x80000000)?0xffffffff:0;
		tmp&=0x3ff;
		max+=tmp;
		max=max>>10;
		max+=0x3c;
		max=max<<10;
		tmp=(max & 0x80000000)?0xffffffff:0;
		tmp&=0x3ff;
		max+=tmp;
		max=max>>10;
		max+=4;
		max=max<<10;
		max-=0xc;
		
		if (max>*(DWORD*)sectStart)
			max=*(DWORD*)sectStart;
			
		max=max>>2;
		
		checksum=0;
		for (int j=0;j<max;j++)
			checksum+=(*(DWORD*)(sectStart+j*4+0xc));
		
		*(DWORD*)(sectStart+4)=checksum;
		printf("New checksum for section %d is %x!\n",i+1,checksum);
	};
	
	printf("Checksums were corrected successfully!\n");
		
	return true;
};

void DecryptOptionfile(BYTE* buf, bool decrypt)
{
	DWORD* dwBuf=NULL;
	DWORD sectStart=0;
	DWORD val=0;
	BYTE val2=0;
	
	for (int i=0;i<9;i++) {
		dwBuf=(DWORD*)buf;
		sectStart=dwBuf[optSections[i]+0x4a];
		dwBuf=(DWORD*)(buf+sectStart);
		
		if (decrypt) {
			for (int j=0;j<(dwBuf[0]>>2);j++) {
				val2=array2[j%0x1be];
				val=dwBuf[j+3] - val2 - ((val2 & 0x80)?0xffffff00:0);
				dwBuf[j+3]=val ^ DECRYPT_FACTOR2;
			};
		} else {
			for (int j=0;j<(dwBuf[0]>>2);j++) {
				val=dwBuf[j+3] ^ DECRYPT_FACTOR2;
				val2=array2[j%0x1be];
				val+=val2 + ((val2 & 0x80)?0xffffff00:0);
				dwBuf[j+3]=val;
			};
		};
	};
	
	if (decrypt)
		printf("Decrypting Option file was successful!\n");
	else
		printf("Encrypting Option file was successful!\n");
			
	return;
};
